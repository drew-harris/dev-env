# "$schema" = "https://jj-vcs.github.io/jj/prerelease/config-schema.json"

[user]
name = "Drew Harris"
email = "drew@drewh.net"

[merge-tools.nvim]
program = "/opt/homebrew/bin/nvim"
edit-args = ["-c", "DiffEditor $left $right $output"]

[merge-tools.gitpatch]
program = "sh"
edit-args = [
  "-c",
  '''
  set -eu
  rm -f "$right/JJ-INSTRUCTIONS"
  git -C "$left" init -q
  git -C "$left" add -A
  git -C "$left" commit -q -m baseline --allow-empty
  mv "$left/.git" "$right"
  git -C "$right" add --intent-to-add --ignore-removal .
  git -C "$right" add -p
  git -C "$right" diff-index --quiet --cached HEAD && { echo "No changes done, aborting split."; exit 1; }
  git -C "$right" commit -q -m split
  git -C "$right" reset -q --hard
''',
]

[merge-tools.difft]
program = "difft"
edit-args = ["$left", "$right"]
diff-args = [
  "--color",
  "always",
  "$left",
  "$right",
]

[merge-tools.dcs]
program = "delta"
edit-args = ["$left", "$right"]
diff-args = [
  "-s",
  "--file-transformation",
  "s|.*/jj-diff-[^/]*/[^/]*/||",
  "$left",
  "$right",
]

[ui]
default-command = ["log", "-T", "builtin_log_comfortable"]
pager = ["delta", "--pager", "less -FRX"]
editor = ["zed", "-w"]
conflict-marker-style = "git"
diff-formatter = [
  "delta",
  "$left",
  "$right",
  "--file-transformation",
  "s|.*/jj-diff-[^/]*/[^/]*/||",
]
graph.style = "square"

[template-aliases]
'format_short_signature(signature)' = "signature.name()"
'format_timestamp(timestamp)' = "timestamp.ago()"
log_with_files = '''
if(root,
  format_root_commit(self),
  label(if(current_working_copy, "working_copy"),
    concat(
      format_short_commit_header(self) ++ "\n",
      separate(" ",
        if(empty, label("empty", "(empty)")),
        if(description,
          description.first_line(),
          label(if(empty, "empty"), description_placeholder),
        ),
      ) ++ "\n",
      if(self.contained_in("recent_work"), diff.summary()),
    ),
  )
)
'''

[aliases]
d = ["desc", "-m"]
n = ["new"]
reheat = ["rebase", "-d", "trunk()", "-s", "all:roots(trunk()..stack(@))"]
stack = ["rebase", "-A", "trunk()", "-B", "closest_merge(@)", "-r"]
l = ["log", "-r", "work"]
open = ["log", "-r", "open()"]
ll = ["log", "-T", "log_with_files"]

# [revsets]
# log = "default-with-hidden"

[revset-aliases]
'trunc' = '(present(@) | ancestors(heads(mine() & immutable_heads()..) | @, 3) | (descendants(trunk(), 3) & ::(heads(mine() & immutable_heads()..) | @)) | present(trunk())) & ~(description("hidden:")::)'

'default-with-hidden' = '(present(@) | ancestors(immutable_heads()..,2) | present(trunk())) & ~(description("hidden:")::)'
'super-default' = '(present(@) | ancestors(immutable_heads()..,2) | present(trunk()))'
'hidden' = '(present(@) | ancestors(immutable_heads()..,2) | present(trunk())) & (description("hidden:")::)'
'trunks' = "main"  # big list of branch names
'local(x)' = "reachable(x, ~::trunks)"
simple = "ancestors(local(@), 2)"
here = "ancestors(reachable(@, trunk()..), 2) | trunk()"
"active(rev)" = "(ancestors(rev) | descendants(rev)) ~ immutable()"
'recent_work' = "ancestors(visible_heads(), 3) & mutable()"
work = "active(@) | active(prev)"
'at' = "@"
'user(x)' = "author(x) | committer(x)"
'mine()' = 'user("drew@drewh.net")'
# By default, show the repo trunk, the remote bookmarks, and all remote tags. We
# don't want to change these in most cases, but in some repos it's useful.
'immutable_heads()' = "present(trunk()) | untracked_remote_bookmarks() | tags()"
# Useful to ignore this, in many repos. For repos like `jj` these are
# consistently populated with a bunch of auto-generated commits, so ignoring it
# is often nice.
'gh_pages()' = 'ancestors(remote_bookmarks(exact:"gh-pages"))'
# Private and WIP commits that should never be pushed anywhere. Often part of
# work-in-progress merge stacks.
'wip()' = 'description(glob-i:"wip:*") | description(glob-i:"[[]WIP[]]*")'
'private()' = 'description(glob-i:"private:*") | description(glob-i:"[[]PRIVATE[]]*")'
'blacklist()' = "wip() | private()"
# stack(x, n) is the set of mutable commits reachable from 'x', with 'n'
# parents. 'n' is often useful to customize the display and return set for
# certain operations. 'x' can be used to target the set of 'roots' to traverse,
# e.g. @ is the current stack.
'stack()' = "stack(@)"
'stack(x)' = "stack(x, 2)"
'stack(x, n)' = "ancestors(reachable(x, mutable()), n)"
# The current set of "open" works. It is defined as: all stacks that are
# reachable from my working copy, or any other commit I wrote.
# n = 1, meaning that nothing from `trunk()` is included, so all resulting
# commits are mutable by definition.
'open()' = "stack(mine() | @, 1)"
# the set of 'ready()' commits. defined as the set of open commits, but nothing
cool = "stack(mine() | @) | trunk() | @"
# that is blacklisted or any of their children.
#
# often used with gerrit, which you can use to submit whole stacks at once:
#
# - jj gerrit send -r 'ready()' --dry-run
'ready()' = "open() ~ descendants(blacklist())"
# Find the megamerge. Mostly useful in combination with other aliases, primarily
# 'sandwich'. Normally when there's only one megamerge, sandwich works perfectly
# fine and is basically "magic". However, there are more complex cases; consider
# something like this which represents a forked repository of an upstream:
#
#
#    ----> P1 ... Pn -----------\
#   /                            \
#  /---> X --\           (main)   \
# B          M1 --> T1 ... Tn --> M2 --> @
#  \---> Y --/
#
# X and Y are typical features on top of base B, combined inside megamerge M1.
# However, we may want changes T1...Tn to go on top of M1, because (in my case)
# they're custom and will never go upstream, but are correctly published as part
# of the fork; Tn is where the main bookmark points. Finally, we have changes P1
# ... Pn which are private and should never be pushed upstream at all.
#
# In this case, sandwich will work poorly because 'reachable(stack(), merges())'
# will resolve to {M1, M2}, which is not what we want for 'rebase -B'. So to
# handle that case, we allow the user to specify the merge via literal tag
# "megamerge". In this case if we 'bookmark set megamerge -r M1' then sandwich
# will always work correctly.
'megamerge()' = "coalesce(present(megamerge), reachable(stack(), merges()))"

[templates]
draft_commit_description = '''
  concat(
    coalesce(description, default_commit_description, "\n"),
    surround(
      "\nJJ: This commit contains the following changes:\n", "",
      indent("JJ:     ", diff.stat(72)),
    ),
    "\nJJ: ignore-rest\n",
    diff.git(),
  )
'''
log_node = '''
label("node",
  coalesce(
    if(!self, label("elided", "⇋")),
    if(current_working_copy, label("working_copy", "◉")),
    if(conflict, label("conflict", "✕")),
    if(immutable, label("immutable", "◆")),
    if(description.starts_with("wip: "), label("wip", "󱍼")),
    if(!mine, label("others", "○")),
    label("normal", "○")
  )
)
'''

[colors]
# Base customizations
"normal change_id" = { bold = true, fg = "magenta" }
"immutable change_id" = { bold = false, fg = "bright cyan" }
# Used by log node template
"node" = { bold = true }
"node elided" = { fg = "bright black" }
"node working_copy" = { fg = "green" }
"node conflict" = { fg = "red" }
"node immutable" = { fg = "bright cyan" }
"node others" = { fg = "#ffa07a" }
"node wip" = { fg = "yellow" }
"node normal" = { bold = false }
